"===========================================================================
"DESCRIPTION:è‡ªç”¨vimrcæ–‡ä»¶ï¼Œfor Linux
"
"Last Change:2017å¹´10æœˆ11æ—¥
"
"Version:1.2
"
"===========================================================================

    " Vim-Plugin Manager
    " Specify a directory for plugins
    " - Avoid using standard Vim directory names like 'plugin'
    if empty(glob('~/.vim/autoload/plug.vim'))
        silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
            \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
        autocmd VimEnter * PlugInstall --sync | source $MYVIMRC
    endif
    call plug#begin('~/.vim/vim_plugin')

    " Make sure using single quotes
    " Shorthand notation for full URL.
    Plug 'altercation/vim-colors-solarized'
    Plug 'iCyMind/NeoSolarized'
    " Plug 'flazz/vim-colorschemes'            "ä¸»é¢˜åˆé›†
    Plug 'vim-airline/vim-airline'                             " çŠ¶æ€æ 
    Plug 'vim-airline/vim-airline-themes'                      " airline ä¸»é¢˜
    " Plug 'edkolev/promptline.vim'                              " bash æç¤ºç¬¦
    " Plug 'edkolev/tmuxline.vim'                                " tmux æç¤ºæ 
    Plug 'yianwillis/vimcdoc'                                  " ä¸­æ–‡å¸®åŠ©æ–‡æ¡£
    Plug 'scrooloose/nerdtree',{'on':'NERDTreeToggle'}         " æ–‡ä»¶æ ‘æµè§ˆ
    Plug 'majutsushi/tagbar',{'on':['Tagbar', 'TagbarToggle', 'TagbarOpen']} " æ–‡ä»¶ç»“æ„
    Plug 'tpope/vim-fugitive'                                  " ç®¡ç† Git ä»“åº“

    Plug 'SirVer/ultisnips'                                    " ä»£ç å—è¡¥å…¨
    Plug 'honza/vim-snippets'                                  " é…åˆ ultisnips
    Plug 'w0rp/ale'                                            " å¼‚æ­¥è¯­æ³•æ£€æŸ¥
    Plug 'chiel92/vim-autoformat'                              " è‡ªåŠ¨æ ¼å¼åŒ–ä»£ç 
    Plug 'hotoo/pangu.vim'                                     " è‡ªåŠ¨æ ¼å¼åŒ–ã€æ ‡å‡†åŒ–ä¸­æ–‡æ’ç‰ˆ

    Plug 'scrooloose/nerdcommenter'                            " æ‰¹é‡ã€å¿«é€Ÿæ³¨é‡Š
    Plug 'easymotion/vim-easymotion'                           " å¿«é€ŸæŸ¥æ‰¾å®šä½
    Plug 'haya14busa/incsearch.vim'                            " å¢é‡æœç´¢
    Plug 'haya14busa/incsearch-fuzzy.vim'                      " æ¨¡ç³Šå¢é‡æœç´¢
    Plug 'haya14busa/incsearch-easymotion.vim'                 " å¢é‡æœç´¢ä¸ easymotion ç»“åˆ
    Plug 'Yggdroot/indentLine'                                 " è‡ªåŠ¨æ˜¾ç¤ºç¼©è¿›çº¿

    Plug 'skywind3000/asyncrun.vim',{'on':'AsyncRun'}          " å¼‚æ­¥åå°ç¼–è¯‘è¿è¡Œ

    " Plug 'lervag/vimtex',{'for': 'tex'}                        " Latex æ’ä»¶
    Plug 'lervag/vimtex'                                       " Latex æ’ä»¶
    Plug 'junegunn/vim-easy-align'                             " å¯¹é½æ’ç‰ˆå·¥å…·
    Plug 'Raimondi/delimitMate'                                " æ‹¬å·é…å¯¹
    Plug 'plasticboy/vim-markdown',{'for': 'markdown'}         " é«˜äº® Markdown, ä¾èµ– tabular
    Plug 'iamcco/mathjax-support-for-mkdp',{'for': 'markdown'} " é¢„è§ˆæ•°å­¦å…¬å¼
    Plug 'iamcco/markdown-preview.vim',{'for':'markdown'}      " å®æ—¶é¢„è§ˆ Markdown
    Plug 'jszakmeister/markdown2ctags',{'for':'markdown'}

    Plug 'tomedunn/vim.modfortran'
    Plug 'kchmck/vim-coffee-script'
    Plug 'spiedeman/keylayout-vim-osx'

    " On-damand loading of plugins
    function! BuildYCM(info)
        " info is a dictionary with 3 fields
        " - name:	name of plugin
        " - status: 'installed', 'updated', or 'unchanged'
        " - force:  set on  PlugInstall! or PlugUpdate!
        if a:info.status ==? 'installed' || a:info.force
            !cd ~/.vim/vim_plugin/YouCompleteMe
            !./install.py --clang-completer --build-dir=$HOME/ycm_build
            !rm -rf ~/ycm_build
            "!bash ~/scripts/vim/youcompleteme.sh
            " !bash ~/config/youcom.sh "for ITP
        endif
    endfunction
    Plug 'Valloric/YouCompleteMe',	{'do': function('BuildYCM'), 'on': []} " å¼ºå¤§çš„è‡ªåŠ¨è¡¥å…¨
    " Plug 'tenfyzhong/CompleteParameter.vim'
    Plug 'junegunn/fzf', {'do': './install --all'}               " å¼ºå¤§çš„æ–‡ä»¶æœç´¢

    " Initialize plugin system
    call plug#end()


""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                              Vim Env                               "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    " è®¾ç½®ä¸­æ–‡å¸®åŠ©
    set helplang=cn
    " Multi-language 
    if has('multi_byte')
        " UTF-8 encoding 
        set encoding=utf-8
        set termencoding=utf-8
        set formatoptions+=nM
        set fileencodings=utf-8,gbk
        scriptencoding utf-8
        
        " if v:lang =~? '^\(zh\)\|\(ja\)\|\(ko\)'
        "     " set ambiwidth=double
        "     set ambiwidth=single
        " endif
    else 
        echoerr 'Sorry, this version of (g)vim was not compiled with +multi_byte'
    endif 
    " Doc directory 
    let helptags=$HOME.'/.vim/doc'
    if has('mouse_sgr')
        set ttymouse=sgr
    endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                              Vim GUI                               "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Basic Setting
    function! BasicSetting()
        set number             "æ˜¾ç¤ºè¡Œå·
        " set nocompatible       "ä¸viä¸å…¼å®¹
        set cursorline         "çªå‡ºæ˜¾ç¤ºå½“å‰è¡Œ
        set cursorcolumn       "çªå‡ºæ˜¾ç¤ºå½“å‰åˆ—
        set ruler              "æ‰“å¼€çŠ¶æ€æ æ ‡å°º
        set showcmd            "è¾“å…¥çš„å‘½ä»¤æ˜¾ç¤ºå‡ºæ¥
        set wildmenu
        set shiftwidth=4       "è®¾å®š<<å’Œ>>å‘½ä»¤ç§»åŠ¨æ—¶çš„å®½åº¦ä¸º4
        set softtabstop=4      "ä½¿å¾—æŒ‰é€€æ ¼é”®æ—¶å¯ä»¥ä¸€æ¬¡åˆ æ‰4ä¸ªç©ºæ ¼
        set tabstop=4          "è®¾å®štabé•¿åº¦ä¸º4
        set expandtab          "ä¿®æ”¹tabä¸º4ä¸ªç©ºæ ¼
        " set autoindent
        set regexpengine=1
        " set relativenumber
        set lazyredraw
        set ttyfast
        set synmaxcol=200
        set nobackup           "è¦†ç›–æ–‡ä»¶æ—¶ä¸å¤‡ä»½
        set autochdir          "è‡ªåŠ¨åˆ‡æ¢å½“å‰ç›®å½•ä¸ºå½“å‰æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•
        set backupcopy=yes     "è®¾ç½®å¤‡ä»½æ—¶çš„è¡Œä¸ºä¸ºè¦†ç›–
        " set nowrapscan         "ç¦æ­¢åœ¨æœç´¢åˆ°æ–‡ä»¶ä¸¤ç«¯æ—¶é‡æ–°æœç´¢
        set incsearch          "å¢é‡æœç´¢
        set hlsearch           "é«˜äº®æ˜¾ç¤ºæœç´¢ç»“æœ
        set ignorecase         "æœç´¢æ—¶å¿½ç•¥å¤§å°å†™
        set smartcase          "ä½†æœ‰ä¸€ä¸ªåŠä»¥ä¸Šå¤§å°å†™æ—¶ä»å¯¹å…¶æ•æ„Ÿ

        set noerrorbells       "å…³é—­é”™è¯¯ä¿¡æ¯å“é“ƒ
        set novisualbell       "å…³é—­ä½¿ç”¨å¯è§†å“é“ƒä»£æ›¿å‘¼å«
        set t_vb=              "ç½®ç©ºé”™è¯¯é“ƒå£°çš„ç»ˆç«¯ä»£ç 
        set updatetime=100
        set noswapfile

        set noshowmatch        "æ’å…¥æ‹¬å·æ—¶ï¼ŒçŸ­æš‚åœ°è·³è½¬åˆ°åŒ¹é…çš„æ‹¬å·ä¸Šå»
        set matchtime=2        "è®¾ç½®ä¸Šä¸€æ¡å‘½ä»¤çš„æŒç»­æ—¶é—´
        set magic              "è®¾ç½®é­”æœ¯,æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼
        set hidden             "å…è®¸åœ¨æœ‰æœªä¿å­˜çš„ä¿®æ”¹æ—¶åˆ‡æ¢ç¼“å†²åŒºï¼Œæ­¤æ—¶çš„ä¿®æ”¹ç”±vimè´Ÿè´£
        set smartindent        "å¼€å¯æ–°è¡Œæ—¶ä½¿ç”¨åªèƒ½è‡ªåŠ¨ç¼©è¿›
        set backspace=indent,eol,start  "ä¸è®¾å®šåœ¨æ’å…¥çŠ¶æ€æ— æ³•ç”¨é€€æ ¼é”®å’ŒDeleteé”®åˆ é™¤å›è½¦ç¬¦
        set cmdheight=1        "è®¾å®šå‘½ä»¤è¡Œçš„è¡Œæ•°ä¸º1
        set textwidth=80       "è®¾å®šä¸€è¡Œè¾“å…¥å­—ç¬¦çš„é•¿åº¦
        set wrap               "è‡ªåŠ¨æŠ˜è¡Œ
        set clipboard+=unnamed  "è®¿é—®ç³»ç»Ÿå‰ªè´´æ¿
        set autoread           "è‡ªåŠ¨è¯»å–ä¿®æ”¹äº†çš„æ–‡ä»¶
    endfunction
    call BasicSetting()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"çŠ¶æ€æ ç›¸å…³
    function! SetStatusLine()
        set laststatus=2       "æ˜¾ç¤ºçŠ¶æ€æ ï¼ˆé»˜è®¤å€¼ä¸º1ï¼Œæ— æ³•æ˜¾ç¤ºçŠ¶æ€æ ï¼‰
        set showtabline=2
        set noshowmode
        set statusline=\ %<%F[%1*%M%*%n%R%H]%=\ %y\ %0(%{&fileformat}\ %{&encoding}\ %c:%l/%L%)\             "è®¾ç½®åœ¨çŠ¶æ€è¡Œæ˜¾ç¤ºçš„ä¿¡æ¯
    endfunction
    call SetStatusLine()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Fold Setting
    function! SetFold()    
        set foldenable         "å¼€å§‹æŠ˜å 
        " set foldmethod=syntax  "è®¾ç½®è¯­æ³•æŠ˜å 
        set foldmethod=manual  "è®¾ç½®æ‰‹åŠ¨æŠ˜å 
        set foldmethod=indent  "è®¾ç½®ç¼©è¿›æŠ˜å 
        set foldcolumn=0       "è®¾ç½®æŠ˜å åŒºåŸŸçš„å®½åº¦
        setlocal foldlevel=0   "è®¾ç½®æŠ˜å å±‚æ•°ä¸º...
        " set foldclose=all      "è®¾ç½®ä¸ºè‡ªåŠ¨å…³é—­æŠ˜å 
        nnoremap <space> @=((foldclosed(line('.'))<0) ? 'zc' : 'zo')<CR>     "ç”¨ç©ºæ ¼é”®æ¥å¼€å…³æŠ˜å 
    endfunction
    call SetFold()    
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Color Setting
    " let fortran_free_source = 1
    function! SetColor()
        set t_Co=256
        syntax on              "è‡ªåŠ¨è¯­æ³•é«˜äº®
        function! MyColorScheme(name, bg)
            execute 'set background='.a:bg
            " execute 'colorscheme '.a:name
            " hi Normal ctermbg=NONE guibg=NONE
            if a:name ==? 'NeoSolarized'
                let g:neosolarized_vertSplitBgTrans=0
                let g:neosolarized_termtrans=1
                execute 'colorscheme '.a:name
                hi Terminal ctermbg=NONE guibg=#073642
                hi Pmenu        cterm=NONE ctermbg=33  ctermfg=234 gui=NONE guibg=#0080fe  guifg=black
                hi PmenuSel     cterm=BOLD ctermbg=34 ctermfg=234 gui=bold guibg=#3bb143  guifg=black
                if a:name ==? 'dark'
                    " hi StatusLine   cterm=reverse
                    " hi Folded       cterm=BOLD ctermbg=black     ctermfg=246
                    " hi SignColumn   cterm=NONE ctermbg=black     ctermfg=none   gui=NONE guifg=NONE guibg=#073642
                    " hi Todo         cterm=NONE ctermbg=black     ctermfg=yellow
                else
                    " hi StatusLine   cterm=reverse
                    " hi Folded       cterm=BOLD ctermbg=lightgrey     ctermfg=246
                    " hi StatusLineNC cterm=none ctermbg=grey
                    " hi SignColumn   cterm=NONE ctermbg=lightgrey ctermfg=none gui=NONE guifg=NONE  guibg=#eee8d5
                endif
            elseif a:name ==? 'dracula'
                if &background ==? 'dark'
                    hi Pmenu cterm=NONE ctermbg=blue ctermfg=234
                    hi PmenuSel     cterm=BOLD ctermbg=darkgreen ctermfg=234
                else
                    hi Pmenu        cterm=BOLD ctermbg=blue      ctermfg=white
                    hi PmenuSel     cterm=BOLD ctermbg=darkcyan  ctermfg=yellow
                endif
            endif
        endfunction

        if has('gui_running')
            set guicursor=a:block-blinkon0
            set guifont=Meslo\ LG\ S\ for\ Powerline:h14
            set guifont=Hack:h14
            set guioptions=t
            set background=light
            set transparency=5
            call MyColorScheme('NeoSolarized', 'light')
            call MyColorScheme('NeoSolarized', 'dark')
        elseif $FROM_SSH ==? 'TRUE'
            call MyColorScheme('Monokai', 'light')
        else 
            if has('termguicolors')
                " fix bug for vim
                set t_8f=[38;2;%lu;%lu;%lum
                set t_8b=[48;2;%lu;%lu;%lum
                " ç›®å‰åœ¨kittyå’Œalacrityä¸­è®¾ç½®truecolorä¼šå‡ºç°ä¸€äº›é—®é¢˜
                " kitty:
                "   åœ¨vimä¸­æ‰“å¼€çš„ç»ˆç«¯ä¸é€æ˜ï¼Œä¸”é¢œè‰²å‡ºé”™
                " alacrity:
                "   åœ¨vimä¸­æ‰“å¼€çš„ç»ˆç«¯ä¸é€æ˜
                " enable true color
                set termguicolors
                " let g:term_colors=['#073642', '#dc322f', '#859900', '#b58900', '#268bd2', '#d33682', '#2aa198', '#eee8d5', '#002b36', '#cb4b16', '#586e75', '#657b83', '#839496', '#6c71c4', '#93a1a1', '#fdf6e3']
                " call term_setansicolors(, term_colors)
            endif
            call MyColorScheme('dracula', 'light')
            call MyColorScheme('Monokai', 'dark')
            call MyColorScheme('NeoSolarized', 'dark')
        endif

        function! BackgroundToggle()
            if &background ==? 'light'
                silent !solarized dark
                call MyColorScheme(g:colors_name, 'dark')
            else
                silent !solarized light
                call MyColorScheme(g:colors_name, 'light')
            endif
        endfunction
        nnoremap <F2> :call BackgroundToggle()<CR>
    endfunction
    call SetColor()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Tab and Buffer
    function! SetTabBuffer()
        nnoremap <C-t>n :tabnew<CR>
        nnoremap <C-t>c :tabclose<CR>

        " "tabæ“ä½œå¿«æ·é”®
        " map <leader>tn :tabnext<cr>
        " map <leader>tp :tabprevious<cr>
        " map <leader>td :tabnew<cr>
        " map <leader>tc :tabclose<cr>
        " map <leader>tm :tabmove<cr>

        "åœ¨å½“å‰ç¼“å†²åŒºè·¯å¾„ä¸‹æ‰“å¼€ä¸€ä¸ªæ–°çš„tab
        "åœ¨åŒä¸€ä¸ªç›®å½•ä¸‹ç¼–è¾‘æ–‡ä»¶æ—¶éå¸¸æœ‰ç”¨
        map <c-t>e :tabedit <c-r>=expand("%:p:h")<cr>/
        " "ç¼“å†²åŒºæ“ä½œå¿«æ·æ–¹å¼
        nnoremap <C-b>n :bnext<CR>
        nnoremap <C-b>p :bprevious<CR>
        inoremap <C-b>n <Esc>:bnext<CR><insert>
        inoremap <C-b>p <Esc>:bprevious<CR>
        "å†æ¬¡æ‰“å¼€æ—¶å›åˆ°æœ€åä¸€æ¬¡è¿›è¡Œä¿®æ”¹çš„åœ°æ–¹
        augroup return_where_leave
            autocmd BufReadPost *
                \ if line("'\"") > 0 && line("'\"") <= line("$") |
                \   exe "normal! g'\"" |
                \ endif
        augroup END
        "è®°ä½ç¼“å†²åŒºå…³é—­æ—¶çš„ä¿¡æ¯
        set viminfo^=%
    endfunction
    call SetTabBuffer()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                            Key Mapping                             "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" For vimrc
"å°†map leaderæ˜ å°„ä¸ºé€—å·","
    let mapleader = ','
    function! SetVimrc()
        "å°†map leaderæ˜ å°„ä¸ºé€—å·","
        let mapleader = ','
        nmap <Leader>s :w!<cr>      "å¿«é€Ÿä¿å­˜
        nmap <Leader>S :wq<cr>      "å¿«é€Ÿä¿å­˜å¹¶é€€å‡º
        nmap <Leader>q :q<cr>       "ä¸ä¿å­˜é€€å‡º
        nmap <Leader>Q :q!<cr>      "ä¸ä¿å­˜å¼ºåˆ¶é€€å‡º
        map <silent> <leader>z :source $MYVIMRC<cr>  "é‡è½½.vimrc
        map <silent> <leader><leader>e  :e $MYVIMRC<cr>   "ç¼–è¾‘.vimrc
        augroup reload_vimrc
            "ç¼–è¾‘.vimrcè¿‡åç«‹å³é‡è½½
            autocmd!
            autocmd BufWritePost $MYVIMRC source %
            autocmd BufWritePost,SourceCmd $MYVIMRC YcmRestartServer
            autocmd BufWritePost $MYVIMRC AirlineRefresh
        augroup END
    endfunction
    call SetVimrc()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" For window
    function! SetWindow()
        "çª—å£åˆ†å‰²æ—¶ï¼Œè¿›è¡Œåˆ‡æ¢çš„æŒ‰é”®çƒ­é”®éœ€è¦è¿æ¥ä¸¤æ¬¡ï¼Œæ¯”å¦‚ä»ä¸‹æ–¹çª—å£ç§»åŠ¨
        "å…‰æ ‡åˆ°ä¸Šæ–¹çª—å£ï¼Œéœ€è¦<c-w><c-w>k,éå¸¸éº»çƒ¦ï¼Œç°åœ¨é‡æ˜ å°„ä¸º<c-k>ï¼Œåˆ‡æ¢
        "çš„æ—¶å€™ä¼šå˜å¾—éå¸¸æ–¹ä¾¿
        nnoremap <Leader><Leader>l <C-w>l
        nnoremap <Leader><Leader>h <C-w>h
        nnoremap <Leader><Leader>k <C-w>k
        nnoremap <Leader><Leader>j <C-w>j
        " nnoremap <C-h> <C-w>h<C-w>
        " nnoremap <C-j> <C-w>j<C-w>
        " nnoremap <C-k> <C-w>k<C-w>
        " nnoremap <C-l> <C-w>l<C-w>
    endfunction
    call SetWindow()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                           File Setting                             "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Buffer
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Fortran
    function! SetFortran()
        let fortran_more_precise=1
        let fortran_do_enddo=1
        let fortran_have_tabs=1
        let fortran_fold=1
        let fortran_fold_conditionals=1
        let s:extfname=expand('%:e')
        function! FreeFormat()
            set syntax=fortran
            let b:fortran_fixed_source=0
            set syntax=text
            set syntax=fortran
        endfunction
        au BufNewFile,BufReadPost *.f90,*.F90 call FreeFormat()
    endfunction
    call SetFortran()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Latex
    function! SetLatex()
        let g:tex_flavor = 'latex' 
        let g:tex_conceal= 0
        let g:tex_fast = 'bcmMPrsSvV'
    endfunction
    call SetLatex()
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                       Plugin Configuration                         "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" YCM
    function! SetYCM()
        "æ‰‹åŠ¨å…³é—­å¼€å¯YCM
        function! YCMTrigger()
            if g:ycm_auto_trigger == 0
                let g:ycm_auto_trigger = 1
                echom 'YCM turns on'
            else
                let g:ycm_auto_trigger = 0
                echom 'YCM turns off'
            endif
        endfunction
        nnoremap <leader>y :call YCMTrigger()<CR>

        " å»¶è¿ŸåŠ è½½
        augroup load_ycm
            autocmd!
            autocmd CursorHold,CursorHoldI *  call plug#load('YouCompleteMe')
                        \| call youcompleteme#Enable() | autocmd! load_ycm
        augroup END

        "è®©Vimçš„è¡¥å…¨èœå•è¡Œä¸ºä¸ä¸€èˆ¬IDEä¸€è‡´ï¼ˆå‚è€ƒVimTip1228ï¼‰
        " ç»å¯¹ä¸è¦åŠ  longest
        set completeopt=menu,menuone
        "æ‰“å¼€é”™è¯¯è¯Šæ–­
        nmap <F7> :YcmDiags<CR>
            "ä¸Šä¸‹å·¦å³é”®çš„è¡Œä¸ºä¼šæ˜¾ç¤ºå…¶ä»–ä¿¡æ¯ï¼ˆinsert mode shortcutsï¼‰
            " inoremap <expr> <Down>     pumvisible() ? '<C-n>' : '<Down>'
            " inoremap <expr> <Up>       pumvisible() ? '<C-p>' : '<Up>'
            " inoremap <expr> <c-d> pumvisible() ? '<PageDown><C-p><C-n>' : '<PageDown>'
            " inoremap <expr> <c-u> pumvisible() ? '<PageUp><C-p><C-n>' : '<PageUp>'
        
            "ipythonè§£é‡Šå™¨è·¯å¾„
            " å¦‚æœvimæ”¯æŒpython3è€Œä¸æ˜¯2,å°±éœ€æŒ‡å®špythonè§£é‡Šå™¨è·¯å¾„
            " let g:ycm_server_python_interpreter='/usr/bin/python'
            " let g:ycm_path_to_python_interpreter='/usr/bin/python'
        "å›è½¦é€‰ä¸­å½“å‰é¡¹
        let g:ycm_key_list_stop_completion = ['<CR>']
        "å…³é—­åŠ è½½.ycm_extra_conf.pyæç¤º
        let g:ycm_confirm_extra_conf=0
        "å¼€å¯YCMåŸºäºæ ‡ç­¾å¼•æ“
        let g:ycm_collect_identifiers_from_tags_files=1
        "è¯­æ³•å…³é”®å­—è¡¥å…¨
        let g:ycm_seed_identifiers_with_syntax=1
        "åœ¨æ³¨é‡Šä¸­ä¹Ÿèƒ½è¡¥å…¨
        let g:ycm_complete_in_comments = 1
        "åœ¨å­—ç¬¦ä¸²ä¸­ä¹Ÿèƒ½è¡¥å…¨
        let g:ycm_complete_in_strings = 1
        "æ³¨é‡Šå’Œå­—ç¬¦ä¸²ä¸­çš„æ–‡å­—ä¹Ÿä¼šè¢«æ”¶å…¥è¡¥å…¨
        let g:ycm_collect_identifiers_from_comments_and_strings = 1
        "å¦‚æœé€‰ä¸­é¡¹åŸºäºè¯­ä¹‰,åˆ™åœ¨æ–‡ä»¶ä¸Šæ–¹å¼¹å‡ºå…¶è¯¦ç»†ä¿¡æ¯
        let g:ycm_add_preview_to_completeopt = 0 "New one
        "è¡¥å…¨åè‡ªåŠ¨å…³é—­é¢„è§ˆçª—å£,å¦‚æœä¸Šä¸€é¡¹ä¸º0,åˆ™æ— å…³ç´§è¦
        let g:ycm_autoclose_preview_window_after_completion= 1
        "å¦‚æœä¸Šä¸Šä¸€é¡¹ä¸º0æˆ–ä¸Šä¸€é¡¹ä¸º1,åˆ™æ— å…³ç´§è¦
        let g:ycm_autoclose_preview_window_after_insertion = 1
        
        let g:ycm_key_invoke_completion = '<leader><leader>s'
        let g:ycm_semantic_triggers = {
                    \'c,cpp,python,f90': ['re!\w{2}']
                    \}

        let g:ycm_use_ultisnips_completer = 1 "New one
        "è·³è½¬åˆ°å®šä¹‰å¤„
        nnoremap <leader>g :YcmCompleter GoTo<CR>
        "æ”¹æ­£é”™è¯¯ï¼Œåªé€‚ç”¨äº C-family language.
        nmap <tab> :YcmCompleter FixIt<CR>
        "YCM é»‘åå•
        let g:ycm_filetype_blacklist = {
                    \ 'tagbar'  : 1,
                    \ 'qf'  : 1,
                    \ 'notes'  : 1,
                    \ 'unite'  : 1,
                    \ 'text'  : 1,
                    \ 'vimwiki' : 1,
                    \ 'pandoc'  : 1,
                    \ 'infolog' : 1,
                    \ 'mail'    : 1,
                    \}
        "YCM ç™½åå•
        " let g:ycm_filetype_whitelist = {
        "     \ 'python': 1,
        "     \ 'c' : 1,
        "     \ 'cpp': 1,
        "     \ 'f90': 1,
        "     \ 'md': 1,
        "     \ 'tex': 1,
        "     \ 'bash': 1,
        "     \}
        "åˆ¤æ–­æ˜¯å¦å†è™šæ‹Ÿç¯å¢ƒä¸­ï¼Œç¡®ä¿YouCompleteMeèƒ½æ‰¾åˆ°ç›¸åº”çš„site packagesæ–‡ä»¶å¤¹
        "python with virtualenv support
        " py << EOF
        " import os
        " import sys
        " if 'VIRTUAL_ENV' in os.environ:
        "     project_base_dir = os.environ['VIRTUAL_ENV']
        "     activate_this = os.path.join(project_base_dir,'bin/activate_this.py')
        "     execfile(activate_this, dict(__file__=activate_this))
        " EOF
    endfunction
    call SetYCM()
    
" Ultisnips
    function! SetUltiSnips()
        let g:UltiSnipsSnippetDirectories=['UltiSnips']
        let g:UltiSnipsSnippetsDir='~/.vim/UltiSnips'
        let g:UltiSnipsExpandTrigger='<c-j>'
        let g:UltiSnipsJumpForwardTrigger='<c-j>'
        let g:UltiSnipsJumpBackwardTrigger='<c-k>'
        let g:UltiSnipsEditSplit='vertical'
            " " make YCM compatible with UltiSnips
            " function! g:UltiSnips_Complete()
            "     call UltiSnips#ExpandSnippet()
            "     if g:ulti_expand_res == 0
            "         if pumvisible()
            "             return '\<c-n>'
            "         else
            "             " call UltiSnips#JumpBackwards()
            "             " if g:ulti_jump_backwards_res == 0
            "             "     return '\<s-n>'
            "             " endif
            "         endif
            "     endif
            " endfunction
            " " function! g:UltiSnips_Reverse()
            "     " call UltiSnips#JumpForwards()
            "     " if g:ulti_jump_forwards_res == 0
            "     " endif
            " " endfunction
            " au InsertEnter * exec 'inoremap <silent> ' . g:UltiSnipsExpandTrigger . ' <C-R>=g:UltiSnips_Complete()<cr>'
            " " au InsertEnter * exec 'inoremap <silent> ' . g:UltiSnipsJumpBackwardTrigger . '<C-R>=g:UltiSnips_Reverse()<cr>'
    endfunction
    call SetUltiSnips()

" Neocomplete
    " function! SetNeocomplete()
    "
    " endfunction
    " call SetNeocomplete()
    
" Nerdtree
    " map <F4> :NERDTreeToggle<CR>     "è®¾ç½®F4ä¸ºæ‰“å¼€nerdtreeçš„å¿«æ·é”®
    let g:NERDTreeWinSize=30

" Tagbar
    function! SetTagbar()
        " æ‰“å¼€ tagbar æ—¶è‡ªåŠ¨è·³è½¬åˆ° tagbar çª—å£
        let g:tagbar_autofocus=1
        " é€‰ä¸­ tag åè·³è½¬è‡³å®šä¹‰å¤„å¹¶è‡ªåŠ¨å…³é—­ tagbar çª—å£
        let g:tagbar_autoclose=0
        " åœ¨å·¦ä¾§æ‰“å¼€
        " let g:tagbar_left=1
        " åœ¨ä¸Šæ–¹æ‰“å¼€ tagbar çª—å£
        " let g:tagbar_vertical=20
        " è®¾ç½®å®½åº¦ 
        let g:tagbar_width=30
        function! TagbarForward()
            if exists('t:NERDTreeBufName') && bufwinnr(bufnr(t:NERDTreeBufName)) != -1
                TagbarOpen fj
            else
                let g:tagbar_left = 1
                " TagbarOpen fjc
                TagbarOpen fj
                let g:tagbar_left = 0
            endif
        endfunction
        nnoremap <leader>f :call TagbarForward()<CR>
        function! ToggleNERDTreeAndTagbar()
            " è·å–å½“å‰çª—å£çš„ç¼“å†²åŒºç¼–å·
            let current_bufid = bufnr('%')
            " æ£€æŸ¥ NERDTree æ˜¯å¦æœ‰æ‰“å¼€
            if exists('t:NERDTreeBufName')
                let nerdtree_open = bufwinnr(t:NERDTreeBufName) != -1
            else
                let nerdtree_open = 0
            endif
            let tagbar_open = bufwinnr('__Tagbar__') != -1
            " æ ¹æ®å½“å‰çŠ¶æ€é‡‡å–é€‚å½“æ“ä½œ
            if nerdtree_open
                if tagbar_open
                    TagbarToggle
                    NERDTreeToggle
                else
                    " è·³è½¬åˆ° NERDTree çª—å£
                    let nerdtree_winid = bufwinnr(t:NERDTreeBufName)
                    exe nerdtree_winid . 'wincmd w'
                    " è·å– NERDTree çª—å£é«˜åº¦
                    let nerdtree_height = winheight(nerdtree_winid)
                    " åœ¨ä¸‹æ–¹æ‰“å¼€ Tagbar
                    let g:tagbar_left = 0
                    let g:tagbar_vertical = nerdtree_height / 2
                    TagbarToggle 
                endif 
            else
                if tagbar_open
                    TagbarToggle
                endif 
                NERDTreeToggle
                let g:tagbar_vertical = winheight(bufwinnr(t:NERDTreeBufName)) / 2
                TagbarToggle
            endif
            " è·³å›åˆ°åˆå§‹çª—å£
            exe bufwinnr(current_bufid) . 'wincmd w'
            let g:tagbar_vertical = 0
        endfunction
        nnoremap <F8> :call ToggleNERDTreeAndTagbar()<CR>
        " Add support for markdown files, é…åˆæ’ä»¶ markdown2ctags
        let g:tagbar_type_markdown = {
            \ 'ctagstype': 'markdown',
            \ 'ctagsbin': '~/.vim/vim_plugin/markdown2ctags/markdown2ctags.py',
            \ 'ctagsargs': '-f - --sort=yes',
            \ 'kinds': [
                \ 's:sections',
                \ 'i:images',
            \ ],
            \ 'sro': '|',
            \ 'kind2scope': {
                \ 's': 'section', 
            \ },
            \ 'sort': 0,
        \ }
    endfunction 
    call SetTagbar()

" Nerdcommenter
    function! SetNerdcommenter()
        let g:NERDSpaceDelims = 1
        let g:NERDCompactSexyComs = 1
        let g:NERDDefaultAlign = 'left'
        let g:NERDAltDelims_java = 1
        let g:NERDCommentEmptyLines = 1
        let g:NERDTrimTrailingWhitespace = 1
    endfunction 
    call SetNerdcommenter()

" Vimtex
    function! SetVimtex()
        if empty(v:servername) && exists('*remote_startserver')
            call remote_startserver('TEX')
        endif
        let g:vimtex_enabled = 1
        let g:vimtex_format_enabled = 1
        function! VimtexTrigger()
            if g:vimtex_enabled == 0
                let g:vimtex_enabled = 1
                echom 'vimtex turns on'
            else
                let g:vimtex_enabled = 0
                echom 'vimtex turns off'
            endif
        endfunction
        " nnoremap <leader>v :call VimtexTrigger()<CR>
        " automatically jump to the first error 
        " but not work well with continuous compilation
        let g:vimtex_quickfix_autojump = 0
        " specify PDF viewer
        let g:vimtex_view_method = 'skim'

        " function! CloseViewers()
        "     if executable('xdotool') && exists('b:vimtex')
        "         \ && exists('b:vimtex.viewer') && b:vimtex.viewer.xwin_id > 0
        "     call system('xdotool windowclose '. b:vimtex.viewer.xwin_id)
        "     endif
        " endfunction

        " augroup vimtex_event_2
        "     au!
        "     au User VimtexEventQuit call CloseViewers()
        " augroup END

        " make YCM work
        if !exists('g:ycm_semantic_triggers')
            let g:ycm_semantic_triggers = {}
        endif
        au VimEnter,BufNewFile,BufReadPre *.tex
                    \   if !exists('g:ycm_semantic_triggers')
                    \ |     let g:ycm_semantic_triggers = {}
                    \ | endif
                    \ | let g:ycm_semantic_triggers.tex = g:vimtex#re#youcompleteme
        " let g:ycm_semantic_triggers.tex = g:vimtex#re#youcompleteme
        let g:vimtex_compiler_latexmk = {
            \ 'background' : 1,
            \ 'build_dir' : '',
            \ 'callback' : 1,
            \ 'continuous' : 1,
            \ 'executable' : 'latexmk',
            \ 'options' : [
            \   '-verbose',
            \   '-file-line-error',
            \   '-synctex=1',
            \   '-interaction=nonstopmode',
            \ ],
            \}
        let g:vimtex_syntax_minted = [
            \ {
            \   'lang' : 'python',
            \   'ignore' : [
            \       'pythonEscape',
            \       'pythonBEscape',
            \       ],
            \ }
            \]
    endfunction
    call SetVimtex()

" Vim-markdown
    function! SetVimmarkdown()
        " YAML front matter
        let g:vim_markdown_frontmatter = 1
        " fenced code block languages
        let g:vim_markdown_fenced_languages = ['python=py', 'viml=vim', 'bash=sh', 'c++=cpp']
        let g:vim_markdown_folding_disabled = 1
        " set header folding level
        let g:vim_markdown_folding_level = 6
        let g:vim_markdown_toc_autofit = 1
        " adjust new list item indent
        let g:vim_markdown_new_list_item_indent = 2
        " disable math conceal with LaTex math syntax enabled
        " let g:tex_conceal = ""
        let g:vim_markdown_math = 1
        " syntax concealing
        let g:vim_markdown_conceal = 0
    endfunction
    call SetVimmarkdown()

" Markdown-Preview
    function! SetMarkdownPreview()
        " è®¾ç½®ä¸º 1 å¯ä»¥åœ¨æ‰“å¼€markdownæ–‡ä»¶æ—¶è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨é¢„è§ˆï¼Œåªåœ¨æ‰“å¼€markdownæ–‡ä»¶æ—¶æ‰“å¼€ä¸€æ¬¡
        let g:mkdp_auto_start= 0
        " è®¾ç½®ä¸º 1 åœ¨ç¼–è¾‘markdownçš„æ—¶å€™æ£€æŸ¥é¢„è§ˆçª—å£æ˜¯å¦æ‰“å¼€ï¼Œæ²¡æœ‰åˆ™æ‰“å¼€
        let g:mkdp_auto_open= 1
        " åˆ‡æ¢ buffer çš„æ—¶å€™è‡ªåŠ¨å…³é—­é¢„è§ˆçª—å£ï¼Œè®¾ç½®ä¸º 0 åˆ™ä¸è‡ªåŠ¨å…³é—­
        let g:mkdp_auto_close= 0
        " è®¾ç½®ä¸º 1 åˆ™åªåœ¨ä¿å­˜æ–‡ä»¶æˆ–é€€å‡ºæ’å…¥æ¨¡å¼çš„æ—¶å€™æ›´æ–°é¢„è§ˆï¼Œé»˜è®¤å®æ—¶é¢„è§ˆ
        let g:mkdp_refresh_slow= 0
        " è®¾ç½®ä¸º 1 åˆ™æ‰€æœ‰æ–‡ä»¶éƒ½å¯ä»¥ç”¨å‘½ä»¤ MarkdownPreview
        " è¿›è¡Œé¢„è§ˆï¼Œé»˜è®¤åªæœ‰markdownæ–‡ä»¶å¯ä»¥ä½¿ç”¨è¯¥å‘½ä»¤
        let g:mkdp_command_for_global= 0

        function! MarkdownPreviewTrigger()
            if g:mkdp_server_started == 0
                :MarkdownPreview
            else
                :MarkdownPreviewStop
            endif
        endfunction
        nnoremap <c-p> :call MarkdownPreviewTrigger()<CR>
        inoremap <c-p> :call MarkdownPreviewTrigger()<CR>
    endfunction 
    call SetMarkdownPreview()

" Easymotion
    function! SetEasymotion()
        " å…³é—­é»˜è®¤æ˜ å°„
        let g:Easymotion_do_mapping = 1
        " å¤§å°å†™ä¸æ•æ„Ÿ
        let g:Easymotion_smartcase = 1
        " è·¨çª—å£æœç´¢ä¸€ï¼ˆä¸¤ï¼‰ä¸ªå­—æ¯
        map f <Plug>(easymotion-overwin-f)
        map s <Plug>(easymotion-overwin-f2)
        " åŒå‘æœç´¢è¯å¤´å’Œè¯å°¾
        map <Leader>w <Plug>(easymotion-bd-w)
        map <Leader>e <Plug>(easymotion-bd-e)
        " è¦†ç›– vim å­—ç¬¦ä¸²æœç´¢ï¼Œå¯ä»¥è·¨çª—å£
        " map / <Plug>(easymotion-sn)
        " line motion 
        map <Leader>l <Plug>(easymotion-lineforward)
        map <Leader>j <Plug>(easymotion-j)
        map <Leader>k <Plug>(easymotion-k)
        map <Leader>h <Plug>(easymotion-linebackward)
    endfunction
    call SetEasymotion()

" Incsearch (fuzzy and easymotion)
    function! SetIncsearch()
        " ç»“åˆ easymotion åæ²¡æœ‰å¿…è¦å†éœ€è¦åŒºåˆ†å¾€å‰ã€å¾€åæœç´¢
        " å¢é‡æœç´¢ä¸ easymotion ç»“åˆ
        function! s:incsearch_config(...) abort
            return incsearch#util#deepextend(deepcopy({
            \   'modules': [incsearch#config#easymotion#module({'overwin': 1})],
            \   'keymap': {
            \     "\<CR>": '<Over>(easymotion)'
            \   },
            \   'is_expr': 0
            \ }), get(a:, 1, {}))
        endfunction
        noremap <silent><expr> / incsearch#go(<SID>incsearch_config({'is_stay': 1}))
        " å¢é‡æ¨¡ç³Šæœç´¢ä¸ easymotion ç»“åˆ
        function! s:config_easyfuzzymotion(...) abort
            return extend(copy({
            \   'converters': [incsearch#config#fuzzyword#converter()],
            \   'modules': [incsearch#config#easymotion#module({'overwin': 1})],
            \   'keymap': {
            \     "\<CR>": '<Over>(easymotion)'
            \   },
            \   'is_expr': 0,
            \   'is_stay': 1,
            \ }), get(a:, 1, {}))
        endfunction
        noremap <silent><expr> z/ incsearch#go(<SID>config_easyfuzzymotion())
    endfunction 
    call SetIncsearch()

" Fzf
    function! SetFzf() 
        let g:fzf_action = {
        \   'alt-t': 'tab split',
        \   '-': 'split',
        \   '/': 'vsplit' }
        let g:fzf_layout={'down': '~50%'}
        " let g:fzf_layout={'window': 'enew'}
        let g:fzf_colors = {'border':  ['fg', 'Pmenu']}
    endfunction
    call SetFzf() 

" ALE
    function! SetALE() 
        autocmd FileType * noremap <buffer> <Leader><Leader>c :ALELint<CR>
        let g:ale_lint_on_enter = 1
        let g:ale_lint_on_text_changed = 'never'
        let g:ale_lint_on_save = 1
        let g:ale_set_quickfix = 1
        " if show the error column forever.
        let g:ale_sign_column_always = 0
        let g:ale_sign_error = 'â€¢â€¢'
        " åªæœ‰æ¥è‡ª g:ale_linters å’Œ b:ale_linters ä¸­çš„ linters ä¼šè¢«å¯åŠ¨
        let g:ale_linters_explicit = 1
        " bash æ–‡ä»¶ä¼šè¿è¡Œ sh çš„ linter
        let g:ale_linter_aliases = {'bash': 'sh',
                                    \'zsh': 'sh',
                                    \'vimwiki': 'markdown',
                                    \}
        let g:ale_linters_ignore = {'python': ['pylint'],
                                   \}
        let g:ale_linters = {'python': ['pyls'],
                            \'sh': ['shellcheck'],
                            \'vim': ['vint'],
                            \'fortran': ['gcc'],
                            \'c':['clang'],
                            \'tex':['lacheck', 'chktex'],
                            \}
        let g:ale_sh_shellcheck_exclusions = 'SC1090,SC2005,SC2046,SC2086,SC2155'

        let g:ale_fortran_gcc_executable = 'gfortran'
        let g:ale_fortran_gcc_options = '-Wall'
        let g:ale_fortran_gcc_use_free_form = 1
        "
        let g:ale_fixers = {
                    \   'c': [
                    \       'clang-format',
                    \   ],
                    \   'python': [
                    \       'yapf',
                    \       'trim_whitespace',
                    \       'remove_trailing_lines',
                    \   ],
                    \   'sh': [
                    \       'shfmt',
                    \       'trim_whitespace',
                    \       'remove_trailing_lines',
                    \   ],
                    \}
        " customize format for error and warning messages.
        " let g:ale_echo_msg_error_str = 'E'
        " let g:ale_echo_msg_warning_str = 'W'
        " let g:ale_echo_msg_format = '[%linter%] %s [%severity%]'
        nmap <silent> <C-k> <Plug>(ale_previous_wrap)
        nmap <silent> <C-j> <Plug>(ale_next_wrap)
        nmap <silent> <F3> <Plug>(ale_fix)
    endfunction 
    call SetALE() 

" Autoformat
    function! SetAutoformat()
        autocmd FileType c,fortran noremap <buffer> <F10> :Autoformat<CR>
        " nmap <buffer> <F8> :Autoformat<CR>
        " æ’ä»¶ä¼šè‡ªåŠ¨è®¾ç½®è¿™ä¸¤é¡¹ï¼Œyapf çš„ä¼˜åŠ¿åœ¨äºä»£ç é£æ ¼çš„å¯å®šåˆ¶æ€§ã€‚
        let g:autoformat_autoindent=0
        let g:autoformat_retab=0
        let g:autoformat_remove_trailing_spaces=0
        " let g:autoformat_verbosemode=1
        autocmd FileType vim,tex let b:autoformat_autoindent=0
        " au BufWrite * :Autoformat
    endfunction
    call SetAutoformat()

" Pangu
    function! SetPangu()
        autocmd BufWritePre *.markdown,*.md,*.text,*txt,*.wiki,*.cnx call PanGuSpacing()
    endfunction
    call SetPangu()

" AsyncRun
    function! SetAsyncRun()
        let $PYTHONUNBUFFERED=1
        " quick run
        imap <F5> <Esc>:call <SID>compile_and_run()<CR>
        nmap <F5> :call <SID>compile_and_run()<CR>
        function! s:compile_and_run()
            exec 'w'
            if &filetype ==? 'fortran'
                exec 'AsyncRun! mpifort % -o %< -qopenmp -fpp -mkl; time ./%<'
            elseif &filetype ==? 'c'
                exec 'AsyncRun! gcc % -o %<; time ./%<'
            elseif &filetype ==? 'cpp'
                exec 'AsyncRun! g++ -std=c++11 % -o %<; time ./%<'
            elseif &filetype ==? 'java'
                exec 'AsyncRun! javac %; time java /%<'
            elseif &filetype ==? 'sh'
                exec 'AsyncRun! time bash %'
            elseif &filetype ==? 'python'
                exec 'AsyncRun! -raw python %'
            elseif &filetype ==? 'tex'
                exec 'VimtexCompile'
            elseif &filetype ==? 'ruby'
                exec 'AsyncRun! time ruby %'
            endif
        endfunction 
        " bind <F9> to open quickfix window rapidly.
        nmap <F9> :call asyncrun#quickfix_toggle(10)<cr>
        " like Emacs, use <M-x> to type commands.
        set timeoutlen=500 ttimeoutlen=100
        exec "set <M-x>=\ex"
        imap <M-x> <Esc>:AsyncRun
        nmap <M-x> :AsyncRun
        " ring bell when finished.
        let g:asyncrun_exit = "silent call system('play ~/Music/notify/facebook.wav  &')"
        " open quickfix window in right way.
        augroup vimrc
            autocmd!
            " autocmd QuickFixCmdPost * call asyncrun#quickfix_toggle(10,1)
            autocmd User AsyncRunStop call asyncrun#quickfix_toggle(10,1)
        augroup END
    endfunction
    call SetAsyncRun()

" Powerline
    function! SetPowerline()
        if has('python')
            python from powerline.vim import setup as powerline_setup
            python powerline_setup()
            python del powerline_setup
        else
            python3 from powerline.vim import setup as powerline_setup
            python3 powerline_setup()
            python3 del powerline_setup
        endif
    endfunction
    " call SetPowerline()

" Airline
    function! SetAirline()
        " let g:airline_theme='powerlineish'
        " let g:airline_theme='papercolor'
        let g:airline_theme='minimalist'
        let g:airline_powerline_fonts = 1
        let g:airline#extensions#tabline#enabled=1
        let g:airline#extensions#tabline#show_tabs = 1
        let g:airline_extensions#tabline#show_buffers = 1
        " let g:airline#extensions#tabline#alt_sep = 1
        let g:airline#extensions#tabline#buffer_nr_show = 1
        " integration with ALE
        let g:airline#extensions#ale#enabled = 1
        " let g:airline_extensions = ['vimtex', 'tagbar']

    endfunction
    call SetAirline()

" Promptline
    function! SetPromptline()
        let git_sha_slice = {
                    \'function_name': 'git_sha',
                    \'function_body': [
                        \'function git_sha {',
                        \'  local sha',
                        \'  sha=$(git rev-parse --short HEAD 2>/dev/null) || return 1',
                        \'  printf "%s" "$sha"',
                        \'}']}

        " let g:promptline_preset = 'powerlineclone'
        let g:promptline_preset = {
                    \'c'    : [ promptline#slices#user(), promptline#slices#battery({'threshold': 30}) ],
                    \'b'    : [ promptline#slices#python_virtualenv() ],
                    \'a'    : [ promptline#slices#cwd({'dir_limit': 2}) ],
                    \'y'    : [ promptline#slices#vcs_branch() ],
                    \'warn' : [ promptline#slices#last_exit_code() ],
                    \'options': {
                        \'left_only_sections' : [ 'c', 'b', 'a', 'y', 'warn' ]}
                    \}
        " å¯ä»¥ä¼ å…¥å­—å…¸
        " let g:promptline_theme = 'airline'
        let g:promptline_theme = {
                    \'c'    : [ 253, 24 ],
                    \'b'    : [ 252, 31 ],
                    \'a'    : [ 8, 249 ],
                    \'y'    : [ 252, 31 ],
                    \'warn' : [ 232, 166 ]
                    \}
        let g:promptline_powerline_symbols = 1
    endfunction
    " call SetPromptline()

" Tmuxline
    function! SetTmuxline()
        " let g:tmuxline_theme = 'iceberg'
        " let g:tmuxline_preset = {
                    \'a'    : '#S',
                    \'b'    : '#W',
                    \'win'  : ['#I', '#W'],
                    \'cwin' : ['#I', '#W', '#F'],
                    \'y'    : ['#(buffer_size)', '%R'],
                    \'z'    : '#h',
                    \}
    endfunction
    " call SetTmuxline()

" Easy-Align
    function! SetEasyAlign()
        xmap ga <Plug>(EasyAlign)
        nmap ga <Plug>(EasyAlign)
    endfunction
    call SetEasyAlign()

" IndentLine
    " let g:indentLine_setConceal = 0
    nmap <leader>i :IndentLinesToggle<cr>
